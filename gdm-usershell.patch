--- ../build/BUILD/gdm-2.0beta4/daemon/slave.c.usershell	Fri Apr 28 00:06:43 2000
+++ gdm-2.0beta4/daemon/slave.c	Fri Apr 28 00:07:56 2000
@@ -250,6 +250,35 @@
     gdm_slave_session_start (login);
 }
 
+static gchar*
+gdm_get_user_shell(void)
+{
+	struct passwd *pw;
+	int i;
+	char *shell;
+	static char *shells [] = {
+		"/bin/bash", "/bin/zsh", "/bin/tcsh", "/bin/ksh",
+		"/bin/csh", "/bin/sh", 0
+	};
+
+#if 0
+	if ((shell = getenv ("SHELL"))){
+		return g_strconcat (shell, NULL);
+	}
+#endif
+	pw = getpwuid(getuid());
+	if (pw && pw->pw_shell) {
+		return g_strdup (pw->pw_shell);
+	} 
+
+	for (i = 0; shells [i]; i++) {
+		if (g_file_exists (shells [i])){
+			return g_strdup (shells[i]);
+		}
+	}
+	
+	return g_strdup("/bin/sh");
+}
 
 static void
 gdm_slave_session_start (gchar *login)
@@ -259,6 +288,7 @@
     gchar *session, *language, *usrsess, *usrlang;
     gboolean savesess = FALSE, savelang = FALSE, usrcfgok = FALSE, authok = FALSE;
     gint i;
+    char *shell, *shell_hyphen;
 
     pwent = getpwnam (login);
     
@@ -423,19 +453,16 @@
 	/* Restore sigmask inherited from init */
 	sigprocmask (SIG_SETMASK, &sysmask, NULL);
 	
-	for(i = 0; i < sysconf(_SC_OPEN_MAX); i++)
-	  close(i);
-
-	/* No error checking here - if it's messed the best response
-           is to ignore & try to continue */
-	open("/dev/null", O_RDONLY); /* open stdin - fd 0 */
-	open("/dev/null", O_RDWR); /* open stdout - fd 1 */
-	open("/dev/null", O_RDWR); /* open stderr - fd 2 */
+	shell = gdm_get_user_shell ();
+	shell_hyphen = g_strconcat ("-", shell, NULL);
 
-	execl (sesspath, NULL);
+	execl (shell, shell_hyphen, sesspath, NULL);
 	
 	gdm_error (_("gdm_slave_session_start: Could not start session `%s'"), sesspath);
 	
+	g_free (shell);
+	g_free (shell_hyphen);
+
 	gdm_slave_session_stop();
 	gdm_slave_session_cleanup();
 	
